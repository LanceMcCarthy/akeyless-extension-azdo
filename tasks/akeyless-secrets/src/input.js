const SDK = require('azure-pipelines-task-lib/task');
const helpers = require('./helpers');

const stringInputs = {
  accessId: 'accessId',
  accessType: 'azureJwt',
  apiUrl: 'apiUrl'
};

const dictInputs = {
  staticSecrets: 'staticSecrets',
  dynamicSecrets: 'dynamicSecrets'
};

const numberInputs = {
  requestTimeout: 'timeout'
};

const fetchAndValidateInput = () => {
  const params = {
    accessId: SDK.getInput('accessId', true),
    azureJwt: SDK.getInput('azureJwt', true),
    apiUrl: SDK.getInput('apiUrl'),
    staticSecrets: SDK.getInput('staticSecrets'),
    dynamicSecrets: SDK.getInput('dynamicSecrets'),
    requestTimeout: SDK.getInput('timeout')
  };

  if (!params['accessId'] || params['accessId'] === undefined) {
    helpers.generalFail('You must provide the access id for your akeyless Auth Method. For instructions, visit https://github.com/LanceMcCarthy/akeyless-extension-azdo/blob/main/docs/getting-started.md.');
  }

  if (!params['azureJwt'] || params['azureJwt'] === undefined) {
    helpers.generalFail('You must provide a JWT token for authentication, this is generated by a Service connection and Azure CLI. For instructions, visit https://github.com/LanceMcCarthy/akeyless-extension-azdo/blob/main/docs/getting-started.md.');
  }

  // check for string types
  for (const [paramKey, inputId] of Object.entries(stringInputs)) {
    if (typeof params[paramKey] !== 'string') {
      helpers.generalFail(`Input '${inputId}' should be a string`);
    }
  }

  // check for bool types
  for (const [paramKey, inputId] of Object.entries(numberInputs)) {
    if (typeof params[paramKey] !== 'number') {
      helpers.generalFail(`Input '${inputId}' should be a number (int)`);
    }
  }

  // check for dictionary types and the contents is valid for akeyless use
  for (const [paramKey, inputId] of Object.entries(dictInputs)) {
    if (typeof params[paramKey] !== 'string') {
      helpers.generalFail(`Input '${inputId}' should be a serialized JSON dictionary with the secret path as a key and the output name as the value`);
    }

    if (!params[paramKey]) {
      continue;
    }

    try {
      const parsed = JSON.parse(params[paramKey]);
      if (parsed.constructor !== Object) {
        helpers.generalFail(`Input '${inputId}' did not contain a valid JSON dictionary`);
      }
      params[paramKey] = parsed;
    } catch (e) {
      if (e instanceof SyntaxError) {
        helpers.generalFail(`Input '${inputId}' did not contain valid JSON`);
      } else {
        throw e;
      }
    }
  }

  return params;
};

exports.fetchAndValidateInput = fetchAndValidateInput;
